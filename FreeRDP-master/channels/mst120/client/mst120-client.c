/**
* FreeRDP: A Remote Desktop Protocol Implementation
* Device Redirection Virtual Channel
*
* Copyright 2010-2011 Vic Lee
* Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>
* Copyright 2015-2016 Thincast Technologies GmbH
* Copyright 2015 DI (FH) Martin Haimberger <martin.haimberger@thincast.com>
* Copyright 2016 Armin Novak <armin.novak@thincast.com>
* Copyright 2016 David PHAM-VAN <d.phamvan@inuvika.com>
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <winpr/crt.h>
#include <winpr/stream.h>

#include <freerdp/types.h>
#include <freerdp/constants.h>
#include <freerdp/channels/log.h>
#include <freerdp/channels/rdpdr.h>

#ifdef _WIN32
#include <windows.h>
#include <dbt.h>
#else
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#endif

#ifdef __MACOSX__
#include <CoreFoundation/CoreFoundation.h>
#include <stdio.h>
#include <dirent.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif

/*#include "rdpdr_capabilities.h"*/

/*
#include "devman.h"
#include "irp.h"
*/

#include "mst120_main.h"
#include "../libfreerdp/core/rdp.h"


UINT mst120_send(mst120Plugin* mst120, wStream* s)
{
	UINT status;
	mst120Plugin* plugin = (mst120Plugin*)mst120;

	if (!mst120 || !s)
		return CHANNEL_RC_NULL_DATA;

	if (!plugin)
		status = CHANNEL_RC_BAD_INIT_HANDLE;
	else
	{
		status = plugin->channelEntryPoints.pVirtualChannelWriteEx(plugin->InitHandle, plugin->OpenHandle,
			Stream_Buffer(s), (UINT32)Stream_GetPosition(s), s, NULL);
	}

	if (status != CHANNEL_RC_OK)
	{
		Stream_Free(s, TRUE);
		WLog_ERR(TAG, "pVirtualChannelWriteEx failed with %s [%08"PRIX32"]",
			WTSErrorToString(status), status);
	}

	return status;
}




static UINT create_free_trigger(mst120Plugin* mst120)
{
	wStream* s;
	s = Stream_New(NULL, 28);

	Stream_Write_UINT32(s, 0);
	Stream_Write_UINT32(s, 0);
	Stream_Write_UINT32(s, 2);
	for (size_t i = 0; i < 8; i++)
	{

		Stream_Write_UINT16(s, 0);
	}

	mst120_send(mst120, s);
	return CHANNEL_RC_OK;
}


static VOID VCAPITYPE mst120_virtual_channel_open_event_ex(LPVOID lpUserParam, DWORD openHandle,
	UINT event,
	LPVOID pData, UINT32 dataLength, UINT32 totalLength, UINT32 dataFlags)
{
	UINT error = CHANNEL_RC_OK;
	mst120Plugin* mst120 = (mst120Plugin*)lpUserParam;

	if (!mst120 || !pData || (mst120->OpenHandle != openHandle))
	{
		WLog_ERR(TAG, "error no match");
		return;
	}

	switch (event)
	{
	case CHANNEL_EVENT_DATA_RECEIVED:
		/*if ((error = rdpdr_virtual_channel_event_data_received(rdpdr, pData,
			dataLength, totalLength, dataFlags)))
			WLog_ERR(TAG,
			"rdpdr_virtual_channel_event_data_received failed with error %"PRIu32"!", error);*/

		break;

	case CHANNEL_EVENT_WRITE_COMPLETE:
		break;

	case CHANNEL_EVENT_USER:
		break;
	}

	if (error && mst120->rdpcontext)
		setChannelError(mst120->rdpcontext, error,
		"mst120_virtual_channel_open_event_ex reported an error");

	return;
}

/**
* Function description
*
* @return 0 on success, otherwise a Win32 error code
*/
static UINT mst120_virtual_channel_event_connected(mst120Plugin* mst120,
	LPVOID pData, UINT32 dataLength)
{
	UINT32 status;
	status = mst120->channelEntryPoints.pVirtualChannelOpenEx(mst120->InitHandle,
		&mst120->OpenHandle, mst120->channelDef.name, mst120_virtual_channel_open_event_ex);

	if (status != CHANNEL_RC_OK)
	{
		WLog_ERR(TAG, "pVirtualChannelOpenEx failed with %s [%08"PRIX32"]",
			WTSErrorToString(status), status);
		return status;
	}

	mst120->queue = MessageQueue_New(NULL);

	if (!mst120->queue)
	{
		WLog_ERR(TAG, "MessageQueue_New failed!");
		return CHANNEL_RC_NO_MEMORY;
	}

	/*if (!(mst120->thread = CreateThread(NULL, 0,
		rdpdr_virtual_channel_client_thread, (void*)rdpdr, 0,
		NULL)))
		{
		WLog_ERR(TAG, "CreateThread failed!");
		return ERROR_INTERNAL_ERROR;
		}*/

	return CHANNEL_RC_OK;
}

/**
* Function description
*
* @return 0 on success, otherwise a Win32 error code
*/
static UINT mst120_virtual_channel_event_disconnected(mst120Plugin* mst120)
{
	UINT error;

	if (mst120->OpenHandle == 0)
		return CHANNEL_RC_OK;

	if (MessageQueue_PostQuit(mst120->queue, 0)
		&& (WaitForSingleObject(mst120->thread, INFINITE) == WAIT_FAILED))
	{
		error = GetLastError();
		WLog_ERR(TAG, "WaitForSingleObject failed with error %"PRIu32"!", error);
		return error;
	}

	MessageQueue_Free(mst120->queue);
	CloseHandle(mst120->thread);
	mst120->queue = NULL;
	mst120->thread = NULL;

	/*if ((error = drive_hotplug_thread_terminate(rdpdr)))
	{
	WLog_ERR(TAG, "drive_hotplug_thread_terminate failed with error %"PRIu32"!", error);
	return error;
	}*/

	error = mst120->channelEntryPoints.pVirtualChannelCloseEx(mst120->InitHandle, mst120->OpenHandle);

	if (CHANNEL_RC_OK != error)
	{
		WLog_ERR(TAG, "pVirtualChannelCloseEx failed with %s [%08"PRIX32"]",
			WTSErrorToString(error), error);
	}

	mst120->OpenHandle = 0;

	if (mst120->data_in)
	{
		Stream_Free(mst120->data_in, TRUE);
		mst120->data_in = NULL;
	}



	return error;
}

static void mst120_virtual_channel_event_terminated(mst120Plugin* mst120)
{
	mst120->InitHandle = 0;
	free(mst120);
}
static VOID VCAPITYPE mst120_virtual_channel_init_event_ex(LPVOID lpUserParam, LPVOID pInitHandle,
	UINT event,
	LPVOID pData, UINT dataLength)
{
	UINT error = CHANNEL_RC_OK;
	mst120Plugin* mst120 = (mst120Plugin*)lpUserParam;

	if (!mst120 || (mst120->InitHandle != pInitHandle))
	{
		WLog_ERR(TAG, "error no match");
		return;
	}

	switch (event)
	{
	case CHANNEL_EVENT_INITIALIZED:
		break;

	case CHANNEL_EVENT_CONNECTED:
		if ((error = mst120_virtual_channel_event_connected(mst120, pData, dataLength)))
			WLog_ERR(TAG, "rdpdr_virtual_channel_event_connected failed with error %"PRIu32"!",
			error);
		//create_free_trigger(mst120);
		break;

	case CHANNEL_EVENT_DISCONNECTED:
		if ((error = mst120_virtual_channel_event_disconnected(mst120)))
			WLog_ERR(TAG, "rdpdr_virtual_channel_event_disconnected failed with error %"PRIu32"!",
			error);
		break;

	case CHANNEL_EVENT_TERMINATED:
		mst120_virtual_channel_event_terminated(mst120);
		break;

	case CHANNEL_EVENT_ATTACHED:
	case CHANNEL_EVENT_DETACHED:
	default:
		WLog_ERR(TAG, "unknown event %"PRIu32"!", event);
		break;
	}

	if (error && mst120->rdpcontext)
		setChannelError(mst120->rdpcontext, error,
		"mst120_virtual_channel_init_event_ex reported an error");

}

/* rdpdr is always built-in */
#define VirtualChannelEntryEx	MS_T120_VirtualChannelEntryEx

BOOL VCAPITYPE VirtualChannelEntryEx(PCHANNEL_ENTRY_POINTS pEntryPoints, PVOID pInitHandle)
{
	UINT rc;
	mst120Plugin* mst120;
	CHANNEL_ENTRY_POINTS_FREERDP_EX* pEntryPointsEx;
	mst120 = (mst120Plugin*)calloc(1, sizeof(mst120Plugin));

	if (!mst120)
	{
		WLog_ERR(TAG, "calloc failed!");
		return FALSE;
	}



	mst120->channelDef.options =
		CHANNEL_OPTION_INITIALIZED |
		CHANNEL_OPTION_ENCRYPT_RDP |
		CHANNEL_OPTION_COMPRESS_RDP |
		CHANNEL_OPTION_SHOW_PROTOCOL;


	//mst120->channelDef.options = 0;
	sprintf_s(mst120->channelDef.name, ARRAYSIZE(mst120->channelDef.name), "MS_T120");
	mst120->sequenceId = 0;
	pEntryPointsEx = (CHANNEL_ENTRY_POINTS_FREERDP_EX*)pEntryPoints;

	if ((pEntryPointsEx->cbSize >= sizeof(CHANNEL_ENTRY_POINTS_FREERDP_EX)) &&
		(pEntryPointsEx->MagicNumber == FREERDP_CHANNEL_MAGIC_NUMBER))
	{
		mst120->rdpcontext = pEntryPointsEx->context;
	}

	CopyMemory(&(mst120->channelEntryPoints), pEntryPoints,
		sizeof(CHANNEL_ENTRY_POINTS_FREERDP_EX));
	mst120->InitHandle = pInitHandle;
	rc = mst120->channelEntryPoints.pVirtualChannelInitEx(mst120, NULL, pInitHandle,
		&mst120->channelDef, 1, VIRTUAL_CHANNEL_VERSION_WIN2000,
		mst120_virtual_channel_init_event_ex);

	if (CHANNEL_RC_OK != rc)
	{
		WLog_ERR(TAG, "pVirtualChannelInitEx failed with %s [%08"PRIX32"]",
			WTSErrorToString(rc), rc);
		free(mst120);
		return FALSE;
	}

	return TRUE;
}
